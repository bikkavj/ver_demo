name: Semantic Versioning

on:
  pull_request:
    types:
      - closed
    branches:
      - staging
      - prod

jobs:
  versioning:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Ensures full commit history for versioning

      - name: Prevent Direct Merging to Prod (Only Allowed from Staging or Hotfix)
        run: |
          base_branch="${{ github.event.pull_request.base.ref }}"
          head_branch="${{ github.event.pull_request.head.ref }}"
          echo "Base Branch: $base_branch"
          echo "Head Branch: $head_branch"

          if [[ "$base_branch" == "prod" && "$head_branch" != "staging" && ! "$head_branch" =~ ^hot/ ]]; then
            echo "Error: Only staging or hotfix (hot/*) branches can be merged into prod!"
            exit 1
          fi

          if [[ "$base_branch" == "staging" && "$head_branch" != "develop" && ! "$head_branch" =~ ^bug/ ]]; then
            echo "Error: Only develop or bugfix (bug/*) branches can be merged into staging!"
            exit 1
          fi

      - name: Fetch Latest Tags
        run: |
          git fetch --prune  # Ensure full commit history
          git tag -d $(git tag -l) || true  # Delete local tags (prevent cache issues)
          git fetch --tags --force  # Fetch latest tags from remote
          git tag --list --sort=-v:refname  # Debugging: Show all tags sorted by version


      - name: Get Semantic Version
        id: versioning
        uses: PaulHatch/semantic-version@v5.4.0
        with:
          tag_prefix: "v"
          major_pattern: "(MAJOR)"
          minor_pattern: "(MINOR)"
          version_format: 'v${major}.${minor}.${patch}-rc.${increment}'
          bump_each_commit: false
          search_commit_body: true
          enable_prerelease_mode: ${{ github.event.pull_request.base.ref != 'prod' }}


      - name: Determine Version Type
        run: |
          set -e  # Exit if any command fails
          base_branch="${{ github.event.pull_request.base.ref }}"
          pr_title="${{ github.event.pull_request.title }}"
          pr_body="${{ github.event.pull_request.body }}"
          new_version="${{ steps.versioning.outputs.version }}"

          echo "Base Branch: $base_branch"
          echo "PR_TITLE: $pr_title"
          echo "PR_BODY: $pr_body"

          prerelease="false"

          if [[ "$base_branch" == "staging" ]]; then
              echo "Generating RC version..."
              git fetch --tags  # Ensure all tags are fetched

              # Get the latest stable version (excluding RC versions)
              latest_stable_tag=$(git tag --list "v*" | grep -E "^v[0-9]+\.[0-9]+\.[0-9]+$" | sort -rV | head -n 1)
              echo "latest_stable_version: $latest_stable_tag"

              if [[ -z "$latest_stable_tag" ]]; then
                  # No previous stable versions, start fresh
                  new_version="v1.0.0-rc.1"
              else
                  # Find the latest RC version for this stable version
                  latest_rc_tag=$(git tag --list | grep -E "^${latest_stable_tag}-rc.[0-9]+" | sort -V | tail -n 1)

                  if [[ -n "$latest_rc_tag" ]]; then
                      # Extract the RC number using `sed` (cross-platform compatibility)
                      current_rc_number=$(echo "$latest_rc_tag" | sed -E 's/.*-rc\.([0-9]+)/\1/')
                      rc_number=$((current_rc_number + 1))
                      new_version="${latest_stable_tag}-rc.${rc_number}"
                  else
                      # No RC exists for the latest stable version, start with rc.1
                      new_version="${latest_stable_tag}-rc.1"
                  fi
              fi
              #setting prerelease true
              prerelease="true"
              echo "New RC Version: $new_version"
          fi

          if [[ "$base_branch" == "prod" ]]; then
            latest_rc_tag=$(git tag --list "v*-rc.*" | sort -V | tail -n 1)

            if [[ -n "$latest_rc_tag" ]]; then
              new_version="${latest_rc_tag%-rc.*}"
            fi

            last_version=$(git tag --list "v*" | sort -V | tail -n 1)
            major=$(echo "$last_version" | cut -d. -f1 | tr -d 'v')
            minor=$(echo "$last_version" | cut -d. -f2)
            patch=$(echo "$last_version" | cut -d. -f3)

            if echo "$pr_title" | grep -q "(MAJOR)" || echo "$pr_body" | grep -q "(MAJOR)"; then
              major=$((major + 1))
              minor=0
              patch=0
            elif echo "$pr_title" | grep -q "(MINOR)" || echo "$pr_body" | grep -q "(MINOR)"; then
              minor=$((minor + 1))
              patch=0
            else
              patch=$((patch + 1))
            fi
            new_version="v$major.$minor.$patch"
            prerelease="false"
          fi

          echo "NEW_VERSION=$new_version" >> $GITHUB_ENV
          echo "PRERELEASE=$prerelease" >> $GITHUB_ENV

      - name: Debug Version
        run: |
          echo "NEW_VERSION=${{ env.NEW_VERSION }}"

      - name: Push New Tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NEW_VERSION: ${{ env.NEW_VERSION }}
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/bikkavj/ver_demo.git
          git tag ${{ env.NEW_VERSION }}
          git push origin ${{ env.NEW_VERSION }}

      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NEW_VERSION: ${{ env.NEW_VERSION }}
          PRERELEASE: ${{ env.PRERELEASE }}
        with:
          tag_name: ${{ env.NEW_VERSION }}
          release_name: Release ${{ env.NEW_VERSION }}
          body: "Automated release for ${{ env.NEW_VERSION }}"
          prerelease: ${{ env.PRERELEASE }}

